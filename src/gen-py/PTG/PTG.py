#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def registerPlayer(self, gameID, playerName, team):
    """
    Parameters:
     - gameID
     - playerName
     - team
    """
    pass

  def unregisterPlayer(self, gameID, playerID):
    """
    Parameters:
     - gameID
     - playerID
    """
    pass

  def setDeck(self, gameID, playerID, deckName, deckSize):
    """
    Parameters:
     - gameID
     - playerID
     - deckName
     - deckSize
    """
    pass

  def moveCard(self, gameID, playerID, abbreviation, index, originalPosition, newPosition, tapped):
    """
    Parameters:
     - gameID
     - playerID
     - abbreviation
     - index
     - originalPosition
     - newPosition
     - tapped
    """
    pass

  def removeCardFrom(self, gameID, playerID, zone, position):
    """
    Parameters:
     - gameID
     - playerID
     - zone
     - position
    """
    pass

  def addCardTo(self, gameID, playerID, cardString, zone, position):
    """
    Parameters:
     - gameID
     - playerID
     - cardString
     - zone
     - position
    """
    pass

  def setCardTo(self, gameID, playerID, cardString, zone, position):
    """
    Parameters:
     - gameID
     - playerID
     - cardString
     - zone
     - position
    """
    pass

  def setLife(self, gameID, playerID, life):
    """
    Parameters:
     - gameID
     - playerID
     - life
    """
    pass

  def setPoison(self, gameID, playerID, posion):
    """
    Parameters:
     - gameID
     - playerID
     - posion
    """
    pass

  def reveal(self, gameID, playerID, abbreviation, index):
    """
    Parameters:
     - gameID
     - playerID
     - abbreviation
     - index
    """
    pass

  def event(self, eventType, gameID, playerID, data):
    """
    Parameters:
     - eventType
     - gameID
     - playerID
     - data
    """
    pass

  def getEvents(self, gameID, sinceIndex):
    """
    Parameters:
     - gameID
     - sinceIndex
    """
    pass

  def listDecks(self, directory):
    """
    Parameters:
     - directory
    """
    pass

  def getDeck(self, directory, deckName):
    """
    Parameters:
     - directory
     - deckName
    """
    pass

  def saveDeck(self, deckName, deck, directory):
    """
    Parameters:
     - deckName
     - deck
     - directory
    """
    pass

  def VERSION(self, ):
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def registerPlayer(self, gameID, playerName, team):
    """
    Parameters:
     - gameID
     - playerName
     - team
    """
    self.send_registerPlayer(gameID, playerName, team)
    return self.recv_registerPlayer()

  def send_registerPlayer(self, gameID, playerName, team):
    self._oprot.writeMessageBegin('registerPlayer', TMessageType.CALL, self._seqid)
    args = registerPlayer_args()
    args.gameID = gameID
    args.playerName = playerName
    args.team = team
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_registerPlayer(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = registerPlayer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "registerPlayer failed: unknown result");

  def unregisterPlayer(self, gameID, playerID):
    """
    Parameters:
     - gameID
     - playerID
    """
    self.send_unregisterPlayer(gameID, playerID)

  def send_unregisterPlayer(self, gameID, playerID):
    self._oprot.writeMessageBegin('unregisterPlayer', TMessageType.CALL, self._seqid)
    args = unregisterPlayer_args()
    args.gameID = gameID
    args.playerID = playerID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def setDeck(self, gameID, playerID, deckName, deckSize):
    """
    Parameters:
     - gameID
     - playerID
     - deckName
     - deckSize
    """
    self.send_setDeck(gameID, playerID, deckName, deckSize)

  def send_setDeck(self, gameID, playerID, deckName, deckSize):
    self._oprot.writeMessageBegin('setDeck', TMessageType.CALL, self._seqid)
    args = setDeck_args()
    args.gameID = gameID
    args.playerID = playerID
    args.deckName = deckName
    args.deckSize = deckSize
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def moveCard(self, gameID, playerID, abbreviation, index, originalPosition, newPosition, tapped):
    """
    Parameters:
     - gameID
     - playerID
     - abbreviation
     - index
     - originalPosition
     - newPosition
     - tapped
    """
    self.send_moveCard(gameID, playerID, abbreviation, index, originalPosition, newPosition, tapped)

  def send_moveCard(self, gameID, playerID, abbreviation, index, originalPosition, newPosition, tapped):
    self._oprot.writeMessageBegin('moveCard', TMessageType.CALL, self._seqid)
    args = moveCard_args()
    args.gameID = gameID
    args.playerID = playerID
    args.abbreviation = abbreviation
    args.index = index
    args.originalPosition = originalPosition
    args.newPosition = newPosition
    args.tapped = tapped
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def removeCardFrom(self, gameID, playerID, zone, position):
    """
    Parameters:
     - gameID
     - playerID
     - zone
     - position
    """
    self.send_removeCardFrom(gameID, playerID, zone, position)

  def send_removeCardFrom(self, gameID, playerID, zone, position):
    self._oprot.writeMessageBegin('removeCardFrom', TMessageType.CALL, self._seqid)
    args = removeCardFrom_args()
    args.gameID = gameID
    args.playerID = playerID
    args.zone = zone
    args.position = position
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def addCardTo(self, gameID, playerID, cardString, zone, position):
    """
    Parameters:
     - gameID
     - playerID
     - cardString
     - zone
     - position
    """
    self.send_addCardTo(gameID, playerID, cardString, zone, position)

  def send_addCardTo(self, gameID, playerID, cardString, zone, position):
    self._oprot.writeMessageBegin('addCardTo', TMessageType.CALL, self._seqid)
    args = addCardTo_args()
    args.gameID = gameID
    args.playerID = playerID
    args.cardString = cardString
    args.zone = zone
    args.position = position
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def setCardTo(self, gameID, playerID, cardString, zone, position):
    """
    Parameters:
     - gameID
     - playerID
     - cardString
     - zone
     - position
    """
    self.send_setCardTo(gameID, playerID, cardString, zone, position)

  def send_setCardTo(self, gameID, playerID, cardString, zone, position):
    self._oprot.writeMessageBegin('setCardTo', TMessageType.CALL, self._seqid)
    args = setCardTo_args()
    args.gameID = gameID
    args.playerID = playerID
    args.cardString = cardString
    args.zone = zone
    args.position = position
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def setLife(self, gameID, playerID, life):
    """
    Parameters:
     - gameID
     - playerID
     - life
    """
    self.send_setLife(gameID, playerID, life)

  def send_setLife(self, gameID, playerID, life):
    self._oprot.writeMessageBegin('setLife', TMessageType.CALL, self._seqid)
    args = setLife_args()
    args.gameID = gameID
    args.playerID = playerID
    args.life = life
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def setPoison(self, gameID, playerID, posion):
    """
    Parameters:
     - gameID
     - playerID
     - posion
    """
    self.send_setPoison(gameID, playerID, posion)

  def send_setPoison(self, gameID, playerID, posion):
    self._oprot.writeMessageBegin('setPoison', TMessageType.CALL, self._seqid)
    args = setPoison_args()
    args.gameID = gameID
    args.playerID = playerID
    args.posion = posion
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def reveal(self, gameID, playerID, abbreviation, index):
    """
    Parameters:
     - gameID
     - playerID
     - abbreviation
     - index
    """
    self.send_reveal(gameID, playerID, abbreviation, index)

  def send_reveal(self, gameID, playerID, abbreviation, index):
    self._oprot.writeMessageBegin('reveal', TMessageType.CALL, self._seqid)
    args = reveal_args()
    args.gameID = gameID
    args.playerID = playerID
    args.abbreviation = abbreviation
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def event(self, eventType, gameID, playerID, data):
    """
    Parameters:
     - eventType
     - gameID
     - playerID
     - data
    """
    self.send_event(eventType, gameID, playerID, data)

  def send_event(self, eventType, gameID, playerID, data):
    self._oprot.writeMessageBegin('event', TMessageType.CALL, self._seqid)
    args = event_args()
    args.eventType = eventType
    args.gameID = gameID
    args.playerID = playerID
    args.data = data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def getEvents(self, gameID, sinceIndex):
    """
    Parameters:
     - gameID
     - sinceIndex
    """
    self.send_getEvents(gameID, sinceIndex)
    return self.recv_getEvents()

  def send_getEvents(self, gameID, sinceIndex):
    self._oprot.writeMessageBegin('getEvents', TMessageType.CALL, self._seqid)
    args = getEvents_args()
    args.gameID = gameID
    args.sinceIndex = sinceIndex
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getEvents(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getEvents_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getEvents failed: unknown result");

  def listDecks(self, directory):
    """
    Parameters:
     - directory
    """
    self.send_listDecks(directory)
    return self.recv_listDecks()

  def send_listDecks(self, directory):
    self._oprot.writeMessageBegin('listDecks', TMessageType.CALL, self._seqid)
    args = listDecks_args()
    args.directory = directory
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listDecks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listDecks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listDecks failed: unknown result");

  def getDeck(self, directory, deckName):
    """
    Parameters:
     - directory
     - deckName
    """
    self.send_getDeck(directory, deckName)
    return self.recv_getDeck()

  def send_getDeck(self, directory, deckName):
    self._oprot.writeMessageBegin('getDeck', TMessageType.CALL, self._seqid)
    args = getDeck_args()
    args.directory = directory
    args.deckName = deckName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDeck(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDeck_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeck failed: unknown result");

  def saveDeck(self, deckName, deck, directory):
    """
    Parameters:
     - deckName
     - deck
     - directory
    """
    self.send_saveDeck(deckName, deck, directory)

  def send_saveDeck(self, deckName, deck, directory):
    self._oprot.writeMessageBegin('saveDeck', TMessageType.CALL, self._seqid)
    args = saveDeck_args()
    args.deckName = deckName
    args.deck = deck
    args.directory = directory
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def VERSION(self, ):
    self.send_VERSION()
    return self.recv_VERSION()

  def send_VERSION(self, ):
    self._oprot.writeMessageBegin('VERSION', TMessageType.CALL, self._seqid)
    args = VERSION_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_VERSION(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = VERSION_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "VERSION failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["registerPlayer"] = Processor.process_registerPlayer
    self._processMap["unregisterPlayer"] = Processor.process_unregisterPlayer
    self._processMap["setDeck"] = Processor.process_setDeck
    self._processMap["moveCard"] = Processor.process_moveCard
    self._processMap["removeCardFrom"] = Processor.process_removeCardFrom
    self._processMap["addCardTo"] = Processor.process_addCardTo
    self._processMap["setCardTo"] = Processor.process_setCardTo
    self._processMap["setLife"] = Processor.process_setLife
    self._processMap["setPoison"] = Processor.process_setPoison
    self._processMap["reveal"] = Processor.process_reveal
    self._processMap["event"] = Processor.process_event
    self._processMap["getEvents"] = Processor.process_getEvents
    self._processMap["listDecks"] = Processor.process_listDecks
    self._processMap["getDeck"] = Processor.process_getDeck
    self._processMap["saveDeck"] = Processor.process_saveDeck
    self._processMap["VERSION"] = Processor.process_VERSION

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_registerPlayer(self, seqid, iprot, oprot):
    args = registerPlayer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = registerPlayer_result()
    result.success = self._handler.registerPlayer(args.gameID, args.playerName, args.team)
    oprot.writeMessageBegin("registerPlayer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unregisterPlayer(self, seqid, iprot, oprot):
    args = unregisterPlayer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.unregisterPlayer(args.gameID, args.playerID)
    return

  def process_setDeck(self, seqid, iprot, oprot):
    args = setDeck_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.setDeck(args.gameID, args.playerID, args.deckName, args.deckSize)
    return

  def process_moveCard(self, seqid, iprot, oprot):
    args = moveCard_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.moveCard(args.gameID, args.playerID, args.abbreviation, args.index, args.originalPosition, args.newPosition, args.tapped)
    return

  def process_removeCardFrom(self, seqid, iprot, oprot):
    args = removeCardFrom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.removeCardFrom(args.gameID, args.playerID, args.zone, args.position)
    return

  def process_addCardTo(self, seqid, iprot, oprot):
    args = addCardTo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.addCardTo(args.gameID, args.playerID, args.cardString, args.zone, args.position)
    return

  def process_setCardTo(self, seqid, iprot, oprot):
    args = setCardTo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.setCardTo(args.gameID, args.playerID, args.cardString, args.zone, args.position)
    return

  def process_setLife(self, seqid, iprot, oprot):
    args = setLife_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.setLife(args.gameID, args.playerID, args.life)
    return

  def process_setPoison(self, seqid, iprot, oprot):
    args = setPoison_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.setPoison(args.gameID, args.playerID, args.posion)
    return

  def process_reveal(self, seqid, iprot, oprot):
    args = reveal_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.reveal(args.gameID, args.playerID, args.abbreviation, args.index)
    return

  def process_event(self, seqid, iprot, oprot):
    args = event_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.event(args.eventType, args.gameID, args.playerID, args.data)
    return

  def process_getEvents(self, seqid, iprot, oprot):
    args = getEvents_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getEvents_result()
    result.success = self._handler.getEvents(args.gameID, args.sinceIndex)
    oprot.writeMessageBegin("getEvents", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listDecks(self, seqid, iprot, oprot):
    args = listDecks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listDecks_result()
    result.success = self._handler.listDecks(args.directory)
    oprot.writeMessageBegin("listDecks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDeck(self, seqid, iprot, oprot):
    args = getDeck_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDeck_result()
    result.success = self._handler.getDeck(args.directory, args.deckName)
    oprot.writeMessageBegin("getDeck", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_saveDeck(self, seqid, iprot, oprot):
    args = saveDeck_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.saveDeck(args.deckName, args.deck, args.directory)
    return

  def process_VERSION(self, seqid, iprot, oprot):
    args = VERSION_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = VERSION_result()
    result.success = self._handler.VERSION()
    oprot.writeMessageBegin("VERSION", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class registerPlayer_args:
  """
  Attributes:
   - gameID
   - playerName
   - team
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.STRING, 'playerName', None, None, ), # 2
    (3, TType.I32, 'team', None, None, ), # 3
  )

  def __init__(self, gameID=None, playerName=None, team=None,):
    self.gameID = gameID
    self.playerName = playerName
    self.team = team

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.playerName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.team = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerPlayer_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerName is not None:
      oprot.writeFieldBegin('playerName', TType.STRING, 2)
      oprot.writeString(self.playerName)
      oprot.writeFieldEnd()
    if self.team is not None:
      oprot.writeFieldBegin('team', TType.I32, 3)
      oprot.writeI32(self.team)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class registerPlayer_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerPlayer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unregisterPlayer_args:
  """
  Attributes:
   - gameID
   - playerID
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'playerID', None, None, ), # 2
  )

  def __init__(self, gameID=None, playerID=None,):
    self.gameID = gameID
    self.playerID = playerID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unregisterPlayer_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 2)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setDeck_args:
  """
  Attributes:
   - gameID
   - playerID
   - deckName
   - deckSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'playerID', None, None, ), # 2
    (3, TType.STRING, 'deckName', None, None, ), # 3
    (4, TType.I32, 'deckSize', None, None, ), # 4
  )

  def __init__(self, gameID=None, playerID=None, deckName=None, deckSize=None,):
    self.gameID = gameID
    self.playerID = playerID
    self.deckName = deckName
    self.deckSize = deckSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.deckName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.deckSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setDeck_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 2)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    if self.deckName is not None:
      oprot.writeFieldBegin('deckName', TType.STRING, 3)
      oprot.writeString(self.deckName)
      oprot.writeFieldEnd()
    if self.deckSize is not None:
      oprot.writeFieldBegin('deckSize', TType.I32, 4)
      oprot.writeI32(self.deckSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class moveCard_args:
  """
  Attributes:
   - gameID
   - playerID
   - abbreviation
   - index
   - originalPosition
   - newPosition
   - tapped
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'playerID', None, None, ), # 2
    (3, TType.STRING, 'abbreviation', None, None, ), # 3
    (4, TType.STRING, 'index', None, None, ), # 4
    (5, TType.I32, 'originalPosition', None, None, ), # 5
    (6, TType.I32, 'newPosition', None, None, ), # 6
    (7, TType.BOOL, 'tapped', None, None, ), # 7
  )

  def __init__(self, gameID=None, playerID=None, abbreviation=None, index=None, originalPosition=None, newPosition=None, tapped=None,):
    self.gameID = gameID
    self.playerID = playerID
    self.abbreviation = abbreviation
    self.index = index
    self.originalPosition = originalPosition
    self.newPosition = newPosition
    self.tapped = tapped

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.abbreviation = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.index = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.originalPosition = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.newPosition = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.tapped = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('moveCard_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 2)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    if self.abbreviation is not None:
      oprot.writeFieldBegin('abbreviation', TType.STRING, 3)
      oprot.writeString(self.abbreviation)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRING, 4)
      oprot.writeString(self.index)
      oprot.writeFieldEnd()
    if self.originalPosition is not None:
      oprot.writeFieldBegin('originalPosition', TType.I32, 5)
      oprot.writeI32(self.originalPosition)
      oprot.writeFieldEnd()
    if self.newPosition is not None:
      oprot.writeFieldBegin('newPosition', TType.I32, 6)
      oprot.writeI32(self.newPosition)
      oprot.writeFieldEnd()
    if self.tapped is not None:
      oprot.writeFieldBegin('tapped', TType.BOOL, 7)
      oprot.writeBool(self.tapped)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeCardFrom_args:
  """
  Attributes:
   - gameID
   - playerID
   - zone
   - position
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'playerID', None, None, ), # 2
    None, # 3
    (4, TType.I32, 'zone', None, None, ), # 4
    (5, TType.I32, 'position', None, None, ), # 5
  )

  def __init__(self, gameID=None, playerID=None, zone=None, position=None,):
    self.gameID = gameID
    self.playerID = playerID
    self.zone = zone
    self.position = position

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.zone = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.position = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeCardFrom_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 2)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    if self.zone is not None:
      oprot.writeFieldBegin('zone', TType.I32, 4)
      oprot.writeI32(self.zone)
      oprot.writeFieldEnd()
    if self.position is not None:
      oprot.writeFieldBegin('position', TType.I32, 5)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addCardTo_args:
  """
  Attributes:
   - gameID
   - playerID
   - cardString
   - zone
   - position
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'playerID', None, None, ), # 2
    (3, TType.STRING, 'cardString', None, None, ), # 3
    (4, TType.I32, 'zone', None, None, ), # 4
    (5, TType.I32, 'position', None, None, ), # 5
  )

  def __init__(self, gameID=None, playerID=None, cardString=None, zone=None, position=None,):
    self.gameID = gameID
    self.playerID = playerID
    self.cardString = cardString
    self.zone = zone
    self.position = position

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cardString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.zone = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.position = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addCardTo_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 2)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    if self.cardString is not None:
      oprot.writeFieldBegin('cardString', TType.STRING, 3)
      oprot.writeString(self.cardString)
      oprot.writeFieldEnd()
    if self.zone is not None:
      oprot.writeFieldBegin('zone', TType.I32, 4)
      oprot.writeI32(self.zone)
      oprot.writeFieldEnd()
    if self.position is not None:
      oprot.writeFieldBegin('position', TType.I32, 5)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setCardTo_args:
  """
  Attributes:
   - gameID
   - playerID
   - cardString
   - zone
   - position
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'playerID', None, None, ), # 2
    (3, TType.STRING, 'cardString', None, None, ), # 3
    (4, TType.I32, 'zone', None, None, ), # 4
    (5, TType.I32, 'position', None, None, ), # 5
  )

  def __init__(self, gameID=None, playerID=None, cardString=None, zone=None, position=None,):
    self.gameID = gameID
    self.playerID = playerID
    self.cardString = cardString
    self.zone = zone
    self.position = position

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cardString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.zone = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.position = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setCardTo_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 2)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    if self.cardString is not None:
      oprot.writeFieldBegin('cardString', TType.STRING, 3)
      oprot.writeString(self.cardString)
      oprot.writeFieldEnd()
    if self.zone is not None:
      oprot.writeFieldBegin('zone', TType.I32, 4)
      oprot.writeI32(self.zone)
      oprot.writeFieldEnd()
    if self.position is not None:
      oprot.writeFieldBegin('position', TType.I32, 5)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setLife_args:
  """
  Attributes:
   - gameID
   - playerID
   - life
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'playerID', None, None, ), # 2
    (3, TType.I32, 'life', None, None, ), # 3
  )

  def __init__(self, gameID=None, playerID=None, life=None,):
    self.gameID = gameID
    self.playerID = playerID
    self.life = life

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.life = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setLife_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 2)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    if self.life is not None:
      oprot.writeFieldBegin('life', TType.I32, 3)
      oprot.writeI32(self.life)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setPoison_args:
  """
  Attributes:
   - gameID
   - playerID
   - posion
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'playerID', None, None, ), # 2
    (3, TType.I32, 'posion', None, None, ), # 3
  )

  def __init__(self, gameID=None, playerID=None, posion=None,):
    self.gameID = gameID
    self.playerID = playerID
    self.posion = posion

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.posion = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setPoison_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 2)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    if self.posion is not None:
      oprot.writeFieldBegin('posion', TType.I32, 3)
      oprot.writeI32(self.posion)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reveal_args:
  """
  Attributes:
   - gameID
   - playerID
   - abbreviation
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'playerID', None, None, ), # 2
    (3, TType.STRING, 'abbreviation', None, None, ), # 3
    (4, TType.STRING, 'index', None, None, ), # 4
  )

  def __init__(self, gameID=None, playerID=None, abbreviation=None, index=None,):
    self.gameID = gameID
    self.playerID = playerID
    self.abbreviation = abbreviation
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.abbreviation = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.index = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reveal_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 2)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    if self.abbreviation is not None:
      oprot.writeFieldBegin('abbreviation', TType.STRING, 3)
      oprot.writeString(self.abbreviation)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRING, 4)
      oprot.writeString(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class event_args:
  """
  Attributes:
   - eventType
   - gameID
   - playerID
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'eventType', None, None, ), # 1
    (2, TType.I32, 'gameID', None, None, ), # 2
    (3, TType.I32, 'playerID', None, None, ), # 3
    (4, TType.LIST, 'data', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, eventType=None, gameID=None, playerID=None, data=None,):
    self.eventType = eventType
    self.gameID = gameID
    self.playerID = playerID
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.eventType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.playerID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.data = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.data.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('event_args')
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.STRING, 1)
      oprot.writeString(self.eventType)
      oprot.writeFieldEnd()
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 2)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.playerID is not None:
      oprot.writeFieldBegin('playerID', TType.I32, 3)
      oprot.writeI32(self.playerID)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.data))
      for iter13 in self.data:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEvents_args:
  """
  Attributes:
   - gameID
   - sinceIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gameID', None, None, ), # 1
    (2, TType.I32, 'sinceIndex', None, None, ), # 2
  )

  def __init__(self, gameID=None, sinceIndex=None,):
    self.gameID = gameID
    self.sinceIndex = sinceIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gameID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.sinceIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEvents_args')
    if self.gameID is not None:
      oprot.writeFieldBegin('gameID', TType.I32, 1)
      oprot.writeI32(self.gameID)
      oprot.writeFieldEnd()
    if self.sinceIndex is not None:
      oprot.writeFieldBegin('sinceIndex', TType.I32, 2)
      oprot.writeI32(self.sinceIndex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEvents_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Event, Event.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = Event()
            _elem19.read(iprot)
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEvents_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter20 in self.success:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listDecks_args:
  """
  Attributes:
   - directory
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'directory', None, None, ), # 1
  )

  def __init__(self, directory=None,):
    self.directory = directory

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.directory = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listDecks_args')
    if self.directory is not None:
      oprot.writeFieldBegin('directory', TType.STRING, 1)
      oprot.writeString(self.directory)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listDecks_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readString();
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listDecks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter27 in self.success:
        oprot.writeString(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDeck_args:
  """
  Attributes:
   - directory
   - deckName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'directory', None, None, ), # 1
    (2, TType.STRING, 'deckName', None, None, ), # 2
  )

  def __init__(self, directory=None, deckName=None,):
    self.directory = directory
    self.deckName = deckName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.directory = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.deckName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDeck_args')
    if self.directory is not None:
      oprot.writeFieldBegin('directory', TType.STRING, 1)
      oprot.writeString(self.directory)
      oprot.writeFieldEnd()
    if self.deckName is not None:
      oprot.writeFieldBegin('deckName', TType.STRING, 2)
      oprot.writeString(self.deckName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDeck_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDeck_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveDeck_args:
  """
  Attributes:
   - deckName
   - deck
   - directory
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deckName', None, None, ), # 1
    (2, TType.STRING, 'deck', None, None, ), # 2
    (3, TType.STRING, 'directory', None, None, ), # 3
  )

  def __init__(self, deckName=None, deck=None, directory=None,):
    self.deckName = deckName
    self.deck = deck
    self.directory = directory

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deckName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.deck = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.directory = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveDeck_args')
    if self.deckName is not None:
      oprot.writeFieldBegin('deckName', TType.STRING, 1)
      oprot.writeString(self.deckName)
      oprot.writeFieldEnd()
    if self.deck is not None:
      oprot.writeFieldBegin('deck', TType.STRING, 2)
      oprot.writeString(self.deck)
      oprot.writeFieldEnd()
    if self.directory is not None:
      oprot.writeFieldBegin('directory', TType.STRING, 3)
      oprot.writeString(self.directory)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VERSION_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VERSION_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VERSION_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VERSION_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
